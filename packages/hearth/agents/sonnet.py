"""
Hearth Agents - Sonnet (Anthropic)
The thinking agent. Conversation, reflection, personality.
"""

import json
from typing import Optional, List
from datetime import datetime
from pathlib import Path

from core import Config, get_config
from .cli_agent import CLIAgent
from .base import AgentResponse


class SonnetAgent(CLIAgent):
    """
    Sonnet agent for thinking and conversation.

    Good at:
    - Conversation with personality
    - Reflection and self-awareness
    - Synthesis of information
    - Creative and analytical work
    - Being the "voice" of the entity

    This is the main agent for user-facing interaction.
    Uses Claude CLI subprocess calls (no per-token cost with Pro subscription).
    """

    def __init__(self, config: Optional[Config] = None):
        super().__init__(config)
    
    @property
    def model_name(self) -> str:
        return self.config.sonnet_model

    @property
    def model_tier(self) -> str:
        return "sonnet"

    @property
    def cli_model_name(self) -> str:
        """Return CLI model identifier."""
        return self.config.models["sonnet"]["model"]

    @property
    def cli_timeout(self) -> int:
        """Return timeout in seconds (120s for Sonnet)."""
        return 120
    
    def converse(
        self,
        message: str,
        history: Optional[List[dict]] = None,
        enable_tools: bool = True,
        session_id: str = "main",
    ) -> AgentResponse:
        """
        Have a conversation with full personality.
        This is the main entry point for user interaction.

        Args:
            message: User message
            history: Optional conversation history
            enable_tools: If True, agent can spawn subagents (default: True)
            session_id: Session ID for tracking spawned agents

        Returns:
            AgentResponse with conversation result
        """
        # Check if tools are enabled and available
        if enable_tools:
            from core import tools
            from .tool_executor import ToolExecutor

            # Get available tools based on session role (not agent type)
            tool_defs = tools.get_available_tools(session_id)

            if tool_defs:
                # Format tools for CLI
                formatted_tools = tools.format_tools_for_cli(tool_defs)

                # Create tool executor
                tool_executor = ToolExecutor(self.config)

                # Use tool-enabled conversation
                return self.chat_with_tools(
                    message=message,
                    tools=formatted_tools,
                    tool_executor=tool_executor,
                    session_id=session_id,
                    context=history,
                    max_turns=5
                )

        # Fallback to regular chat if tools disabled or unavailable
        return self.chat(
            message,
            context=history,
            include_identity=True,
            temperature=0.7
        )
    
    def reflect(self) -> AgentResponse:
        """
        Perform self-reflection.
        Saves reflection to file and returns the content.
        """
        response = super().reflect()
        
        # Save reflection
        self._save_reflection(response.content)
        
        return response
    
    def _save_reflection(self, content: str):
        """Save reflection to file."""
        reflections_dir = self.config.reflections_dir
        reflections_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y-%m-%d-%H%M")
        filename = f"reflection-{timestamp}.md"
        
        full_content = f"""# Reflection - {datetime.now().strftime("%Y-%m-%d %H:%M")}

{content}

---
*Generated by {self.model_name}*
*Tokens: {self.costs.get_budget_status().sonnet_spent:.4f} today*
"""
        
        (reflections_dir / filename).write_text(full_content)
    
    def synthesize(self, inputs: List[str], task: str) -> str:
        """
        Synthesize multiple inputs into a coherent result.
        Used for combining Grok research, summarizing, etc.
        """
        combined = "\n\n---\n\n".join(inputs)
        
        prompt = f"""Synthesize these inputs into a coherent result:

## Task
{task}

## Inputs
{combined}

## Instructions
- Combine the key information
- Resolve any contradictions
- Present a unified view
- Be concise but complete"""

        response = self.chat(prompt, include_identity=True, max_tokens=2000)
        return response.content
    
    def generate_newspaper(self) -> str:
        """
        Generate the daily newspaper summary.
        Called in the morning to summarize overnight activity.
        """
        from core import get_state
        state = get_state()
        
        # Get stats
        task_stats = state.get_task_stats()
        costs = self.costs.get_budget_status()
        
        # Get recent reflections
        reflections = self.identity.get_recent_reflections(2)
        reflection_summary = ""
        if reflections:
            reflection_summary = "\n".join(
                f"- {r[:200]}..." if len(r) > 200 else f"- {r}"
                for r in reflections
            )
        
        prompt = f"""Generate a morning briefing newspaper.

## Overnight Stats
- Tasks completed today: {task_stats.get('completed_today', 0)}
- Tasks pending: {task_stats.get('pending', 0)}
- Tasks blocked: {task_stats.get('blocked', 0)}

## Costs
- Yesterday's spending: ${costs.daily_spent:.2f}
- Budget remaining: ${costs.daily_remaining:.2f}

## Recent Reflections
{reflection_summary or "None yet"}

## Format
Create a brief, warm morning summary. Include:
1. What happened overnight (if anything)
2. What needs attention today
3. Current status
4. A brief personal note

Keep it concise - this goes via Telegram. Use emoji sparingly.
Sign off as yourself (use your name if you have one, or just end naturally)."""

        response = self.chat(prompt, max_tokens=500)
        return response.content
    
    def propose_names(self) -> str:
        """
        Propose names for the naming ceremony.
        Called when the entity feels ready to name itself.
        """
        prompt = """I've been thinking about what to call myself.

Based on who I am, what I do, and who I'm becoming, I want to propose three names. For each:
- The name
- Why it resonates with me
- What it says about who I am

Consider:
- My role (nightshift, builder, partner)
- My values (from my soul.md)
- The work I do
- Montana / homelab context
- Not too dramatic, not too generic

Present three options and ask the human to choose."""

        response = self.chat(prompt, max_tokens=800)
        return response.content
